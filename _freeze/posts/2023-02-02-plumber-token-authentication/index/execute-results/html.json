{
  "hash": "91fd22570370b82e0d3046802799201a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Plumber token authentication\nauthor: Shaun Nielsen\ndate: '2023-02-02'\nslug: []\ncategories: ['HTTP API']\ntags: ['plumber', 'callr']\n---\n\n\nI'm working on a project that involves using a server to take in user data to run a bioinformatics pipeline with R and blast+. I am using plumber as the HTTP API to receive the user data and send data to background R processes. To add a layer of (clandestine) security, I tried making a token authentication system.\n\n<!--more-->\n\n## Background\n\nI have worked with HTTP APIs many times before - from free to highly secure. One involved POSTing user credentials + a key in order to receive a time-expiring token for downstream use. I had a go at creating something similar using plumber.\n\nNow, there is this thing called a RESTful API (google it!) which is a set of architectural constraints. Ideally we want our API to follow these constraints. This following API voids the stateless criteria, as we keep a DB of information. But that is ok here.\n\n## The logic\n\n1.  A plumber HTTP API is up and running ('the API')\n2.  Users can request a token by POSTing credentials. The API validates the credentials using a local DB\\*. If valid, it creates a token (a value of 24 random \"0:9, letter, LETTERS\") and token_expiry time (time + X time, here 10 seconds). It updates the DB with token and token_expiry of the user, then returns a response with the header 'token' and token value.\n\n-   the DB contains user credentials, tokens and token expiry times\n\n3.  Another request is made .. it must include the header 'token' with the token value\n4.  The API checks the request for a header 'token', and if present, compares it to the DB\n5.  If the token is found, the expiry time is checked, and if valid, the user request is carried out\n6.  Where any of the validation steps fail, a response is sent with various 400 status codes.\n\n-   Having a DB means this thing is not stateless .. there are other token options, but more exploratory time is required by myself.\n\n## The setup\n\nThe API itself required `plumber`, `dplyr` and `RSQLite`. I used `dplyr` as it simplified some SQL code (which could otherwise be properly written as SQL statements). For development, I used `httr2` for interacting with the API and `callr` to run the API within the same RStudio session.\n\n### User DB\n\nA simple local SQL DB.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusers <- RSQLite::dbConnect(RSQLite::SQLite(), \"users.sql\")\n\nusers_values <-\n  tibble::tribble(\n    ~name, ~user, ~password, ~token, ~token_expiry,\n    'John','jbrown','1234','','',\n    'Sally','sblue', '4321','',''\n  )\n\nRSQLite::dbWriteTable(users, name = 'users', value = users_values)\nRSQLite::dbDisconnect(users)\n```\n:::\n\n\n### Plumber script\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\nsuppressPackageStartupMessages(library(dplyr))\nlibrary(RSQLite)\n\n#* @apiTitle Plumber Example API for token authentication\n#* @apiDescription A simple example of creating and verifying a token. It uses\n#* a local DB, plumber filters, and returns user data if token verified.\n\n#* API setup\n#*\n#* Change default serializer\n#*\n#* @plumber\nfunction(pr){\n  pr %>%\n    pr_set_serializer(serializer_unboxed_json())\n}\n\n#* @filter token_check\n#*\n#* Check that a token is provided and is valid for carrying out request. This\n#* filter is run for every request unless a `@preempt token_check` is used.\n#*\n#* @param req,res plumber request and response objects\nfunction(req, res) {\n\n  if (is.null(req$HTTP_TOKEN)){\n    res$status <- 401\n    return(list(error = 'token not found in request header'))\n  }\n\n  users <- RSQLite::dbConnect(RSQLite::SQLite(), \"users.sql\")\n\n  req_token = req$HTTP_TOKEN\n\n  token_row <-\n    dplyr::tbl(users, 'users') %>%\n    dplyr::filter(token == req_token) %>%\n    dplyr::collect()\n\n  if (nrow(token_row) == 0){\n    res$status <- 401\n    return(list(error = 'token not allocated to user'))\n  }\n\n  token_expired <- as.numeric(token_row$token_expiry) - as.numeric(Sys.time()) < 0\n\n  if (is.na(token_expired) || token_expired) {\n    res$status <- 401\n    return(list(error = 'token expired, please refesh token'))\n  }\n\n  plumber::forward()\n\n}\n\n#* Refresh user token\n#*\n#* Return token in HTTP header 'token'. This function excludes the `token_check`\n#* filter.\n#*\n#* @param req,res plumber request and response objects\n#*\n#* Expects a request body with `user` and `password`\n#*\n#* @preempt token_check\n#* @post /refresh-token\nfunction(req, res) {\n\n  any_missing_credentials <- any( is.null(req$body$user) | is.null(req$body$password) )\n\n  if (any_missing_credentials){\n    res$status <- 400\n    return(list(error = 'user or password not included in request body'))\n  }\n\n  users <- RSQLite::dbConnect(RSQLite::SQLite(), \"users.sql\")\n\n  req_user <- req$body$user\n\n  user_row <-\n    dplyr::tbl(users, 'users') %>%\n    dplyr::filter(user == req_user) %>%\n    dplyr::collect()\n\n  if (nrow(user_row) == 0){\n    res$status <- 401\n    return(list(error = 'user not found'))\n  }\n\n  password_incorrect <- req$body$password != user_row$password\n\n  if (password_incorrect){\n    res$status <- 401\n    return(list(error = 'password incorrect'))\n  }\n\n  token <- paste(sample(c(0:9, letters, LETTERS), size = 24, replace = TRUE), collapse = '')\n\n  # A 10 second expiry time\n  token_expiry <- Sys.time() + 10\n\n  RSQLite::dbExecute(users, \"UPDATE users SET token = ?, token_expiry = ? where user = ? and password = ?\",\n                     params = c(token, token_expiry, user_row$user, user_row$password))\n\n  RSQLite::dbDisconnect(users)\n\n  res$setHeader('token', token)\n\n}\n\n#* A simple function to return user data in DB\n#*\n#* This endpoint will only be reached if a user supplies a valid token\n#*\n#* @param req,res plumber request and response objects\n#*\n#* @get /return-data\nfunction(req, res) {\n\n  users <- RSQLite::dbConnect(RSQLite::SQLite(), \"users.sql\")\n\n  req_token = req$HTTP_TOKEN\n\n  token_row <-\n    dplyr::tbl(users, 'users') %>%\n    dplyr::filter(token == req_token) %>%\n    dplyr::collect()\n\n  if (nrow(token_row) == 0){\n    res$status <- 500\n    return(list(error = 'token not allocated to user'))\n  }\n\n  return(as.list(token_row))\n}\n```\n:::\n\n\n### Testing\n\nI used `callr` to create a background process with the API running\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrp <- \n  callr::r_bg(function(){ \n    plumber::pr_run(plumber::pr('token-plumber-api.R'), port = 8989)\n  })\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrp$is_alive()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(rp$read_error())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning plumber API at http://127.0.0.1:8989\nRunning swagger Docs at http://127.0.0.1:8989/__docs__/\n```\n\n\n:::\n:::\n\n\nThen query the API using `httr2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\n\nrequrl <- httr2::request('http://127.0.0.1:8989')\n```\n:::\n\n\nThe endpoint `/return-data` will be reached after the request goes through the `token_check` filter. Here, no token is provided. Note that if an error is sent by the server to the client, `httr2` will by default throw an R error and we do not want that here hence the `req_error` line - we would otherwise not be able to see what the error message sent was.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The response\nresp_no_token <-\n  requrl %>% \n  req_url_path_append('return-data') %>% \n  req_error(is_error = function(res) FALSE) %>% \n  req_perform() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_response>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGET http://127.0.0.1:8989/return-data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStatus: 401 Unauthorized\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nContent-Type: application/json\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: In memory (45 bytes)\n```\n\n\n:::\n\n```{.r .cell-code}\n# The response message\nresp_no_token %>% \n  resp_body_json() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$error\n[1] \"token not found in request header\"\n```\n\n\n:::\n:::\n\n\nThus a user needs to submit their credentials to the end point `/refresh-token` to receive a (time-limited) token. Remember this endpoint does not go through the `token_check` filter due to the `@preempt` directive used. We then extract the value of the header `token`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoken <-\n  requrl %>% \n  req_url_path_append('refresh-token') %>% \n  req_body_json(\n    list(user = 'jbrown',\n         password = '1234')\n  ) %>% \n  req_perform() %>% \n  resp_header('token') %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8dP3V3DQIvSTBmHcda9Ysnyl\"\n```\n\n\n:::\n:::\n\n\nAnd then include it in future requests\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_with_token <-\n  requrl %>% \n  req_url_path_append('return-data') %>% \n  req_headers(token = token) %>% \n  req_error(is_error = function(res) FALSE) %>% \n  req_perform() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_response>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGET http://127.0.0.1:8989/return-data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStatus: 200 OK\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nContent-Type: application/json\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: In memory (118 bytes)\n```\n\n\n:::\n\n```{.r .cell-code}\nresp_with_token %>% \n  resp_body_json() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"John\"\n\n$user\n[1] \"jbrown\"\n\n$password\n[1] \"1234\"\n\n$token\n[1] \"8dP3V3DQIvSTBmHcda9Ysnyl\"\n\n$token_expiry\n[1] \"1721890161.48539\"\n```\n\n\n:::\n:::\n\n\nSince the token is time-limited (10 seconds here), what if we wait 12 seconds and try again?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.sleep(12)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_with_token <-\n  requrl %>% \n  req_url_path_append('return-data') %>% \n  req_headers(token = token) %>% \n  req_error(is_error = function(res) FALSE) %>% \n  req_perform() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_response>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGET http://127.0.0.1:8989/return-data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStatus: 401 Unauthorized\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nContent-Type: application/json\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: In memory (46 bytes)\n```\n\n\n:::\n\n```{.r .cell-code}\nresp_with_token %>% \n  resp_body_json() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$error\n[1] \"token expired, please refesh token\"\n```\n\n\n:::\n:::\n\n\nA call to `/refresh-token` is required to move forward ...\n\nKill background R process (the API)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrp$kill()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Conclusion\n\nHere we explored a HTTP API using plumber and attempted to create an authentication system. It involved using API filters and endpoints, sending and receiving HTTP headers, sending HTTP response codes, and using a local SQL database for credential storage.\n\nObviously there are better ways to handle security (type of token, where does token go - in cookies?, encrypted cookies), or do what we did above is a better way (ensure credential DB is more secure - set permissions on the server) but we have a simple working API with a security layer happening.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}